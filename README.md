# My LeetCode Solutions 


## Backstory  
Since 2022, I've been through 3 coding bootcamps - 2 Full Stack Java bootcamps, and 1 that focused more on cloud development. Out of all 3 of my bootcamps, none of them taught data structures and algorithms. The most advanced data structure we were taught were arrays. 

I recently applied for an apprenticeship with a unicorn startup company. Around the time that I first applied, I started taking several courses (AlgoMonster, Interview Cake, and Grokking the Coding Interview) on data structures and algorithms. I started grinding on LeetCode before I even knew I had made it to the technical round of the interview process. These LeetCode solutions are all the problems that I've solved since finding out I made it to the technical round. 

Since I had only ever done 1 technical interview before and I knew that you're supposed to explain your thought process behind each solution, I started recording myself while solving different LeetCode problems, talking out loud and explaining my approach and posting the videos on my LinkedIn. Each solution in this repo has an explanation which I've typed out in my own words, but if a walkthrough in real-time would be more helpful for you to understand, I've included the link to my LinkedIn profile below. 

My goal in sharing these solutions with my explanations and video walkthroughs is to help other bootcamp grads and self-taught developers who may not have a strong foundation in data structures and algorithms. I'll be continuing to add to this repo as I solve more problems in the future. 




## Programming Language Used 

* Java 



## Data Structures Used 

* <b>Arrays</b>: Arrays in Java are fixed-size data structures that store elements of the same type sequentially in memory. They provide indexed access to elements, allowing efficient retrieval and modification. Once initialized, the size of an array cannot be changed.

* <b>ArrayLists</b>: ArrayLists are dynamic arrays in Java that can grow or shrink in size dynamically. They are part of the Java Collections Framework and are implemented using an array internally. ArrayLists provide methods to add, remove, modify, and access elements efficiently. They can store elements of any reference type, including objects.

* <b>Sets</b>: Sets in Java are collections that store unique elements, meaning duplicate elements are not allowed. They do not maintain insertion order. Sets are useful for tasks that require uniqueness, such as eliminating duplicates from a collection or testing set membership efficiently. The Java Collections Framework provides several implementations of the Set interface, such as HashSet, TreeSet, and LinkedHashSet.

* <b>Stacks</b>: Stacks are data structures that follow the Last In, First Out (LIFO) principle. Elements are added and removed from the top of the stack. In Java, the Stack class is available in the java.util package and extends the Vector class. Stacks are commonly used in tasks like implementing function call stacks, backtracking algorithms, and expression evaluation.

* <b>HashMaps</b>: HashMaps in Java are implementations of the Map interface that store key-value pairs. They provide fast retrieval of values based on keys. HashMaps do not guarantee the order of elements. They allow null keys and null values (but only one null key). HashMaps use hashing techniques internally to efficiently store and retrieve key-value pairs.


## Additional Data Structures That Will Be Used 

* <b>Linked Lists</b>: Linked Lists are linear data structures where each element, known as a node, contains a reference to the next node in the sequence. They consist of a series of nodes, each containing data and a pointer to the next node. Linked Lists can be singly linked (each node points to the next node) or doubly linked (each node points to both the next and previous nodes). They allow for efficient insertion and deletion operations, especially when dealing with large datasets or frequent modifications.

* <b>Queues</b>: Queues are linear data structures that follow the First In, First Out (FIFO) principle, where elements are inserted at the end (rear) and removed from the front (front). They represent a collection of elements with operations like enqueue (adding an element to the rear) and dequeue (removing an element from the front). Queues are commonly used in scenarios where the order of elements matters, such as job scheduling, breadth-first search algorithms, and buffering in data processing. Java provides the Queue interface and various implementations such as LinkedList and ArrayDeque for creating queues. Additionally, Java's PriorityQueue class provides a priority queue implementation that can also be used as a queue with priority-based ordering of elements. 

* <b>Trees</b>: Trees are hierarchical data structures consisting of nodes connected by edges. They have a root node at the top and may have child nodes branching out from the root. Trees are used to represent hierarchical relationships and are common in database indexing, file systems, and hierarchical data representations. Common types of trees include binary trees, binary search trees, AVL trees, and B-trees. 

* <b>Heaps</b>: Heaps are binary trees that satisfy the heap property, which states that each parent node must be greater than or equal to (in a max heap) or less than or equal to (in a min heap) its child nodes. Heaps are commonly used to implement priority queues, where elements with higher priorities are dequeued first. Java provides a PriorityQueue class that implements a priority queue using a heap data structure.

* <b>Tries</b>: Tries, also known as prefix trees, are tree-like data structures used to store a dynamic set of strings where each node represents a common prefix. Tries are particularly useful for efficient string searching, prefix matching, and autocomplete features. They have a node structure that allows for efficient retrieval of strings based on their prefixes. In Java, tries are often implemented using recursive structures or arrays to represent the tree nodes.

* <b>Graphs</b>: Graphs are non-linear data structures consisting of vertices (nodes) and edges (connections) that link these vertices. They represent relationships between objects and are used to model complex networks such as social networks, transportation systems, and computer networks. Graphs can be directed (edges have a specific direction) or undirected (edges do not have a direction). Java does not have a built-in graph implementation, but graphs can be implemented using adjacency lists, adjacency matrices, or other custom data structures. 




### Links

* [LeetCode](https://www.leetcode.com)




### Author

:woman_technologist: Erica Ayala

* [LinkedIn](https://www.linkedin.com/in/ayalavirtual)

* [GitHub](https://www.github.com/AyalaVirtual) 



